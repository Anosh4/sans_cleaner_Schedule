from notion_client import Client
from datetime import datetime, timedelta
import calendar
import os

# Notion API Tokenê³¼ Database IDë¥¼ í™˜ê²½ ë³€ìˆ˜ì—ì„œ ê°€ì ¸ì˜¤ê±°ë‚˜ ê¸°ë³¸ê°’ ì‚¬ìš©
NOTION_TOKEN = os.environ.get("NOTION_TOKEN", "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")
DATABASE_ID = os.environ.get("NOTION_DATABASE_ID", "1b66b54dd16f8051a7beeed441be3c17")

notion = Client(auth=NOTION_TOKEN)

day_map = {
    "Monday": "(ì›”)", "Tuesday": "(í™”)", "Wednesday": "(ìˆ˜)",
    "Thursday": "(ëª©)", "Friday": "(ê¸ˆ)", "Saturday": "(í† )", "Sunday": "(ì¼)"
}

def get_korean_date(date_obj):
    weekday = date_obj.strftime('%A')
    korean_day = day_map.get(weekday, weekday)
    return f"{date_obj.year % 100}ë…„ {date_obj.month}ì›” {date_obj.day}ì¼ {korean_day}"

def get_cleaning_messages():
    result_text = "[ìë™ ë©”ì„¸ì§€]\nğŸ§¼ ì²­ì†Œ ë‹´ë‹¹ìë¶„ì´ ë°°ì •ë˜ì§€ ì•Šì€ ì¼ì • ëª©ë¡ì…ë‹ˆë‹¤.\n"

    response = notion.databases.query(
        database_id=DATABASE_ID,
        filter={
            "property": "ìƒíƒœ",
            "status": {
                "equals": "ì²­ì†Œ ë°°ì • í•„ìš”"
            }
        }
    )

    for page in response["results"]:
        props = page["properties"]
        date_data = props.get("ì²­ì†Œ ì¼ì •", {}).get("date")
        if not date_data or not date_data.get("start"):
            continue

        try:
            date = datetime.fromisoformat(date_data["start"])
            people = props.get("ì˜ˆì•½ì¸ì›", {}).get("number", 0)
            formatted = f"{get_korean_date(date)}, ì˜ˆì•½ì ìˆ˜ëŠ” {people}ëª… ì…ë‹ˆë‹¤."
            result_text += formatted + "\n"
        except Exception as e:
            print("âš ï¸ ë‚ ì§œ íŒŒì‹± ì˜¤ë¥˜:", e)

    result_text += "\n[ì²­ì†Œ ìº˜ë¦°ë” í™•ì¸í•˜ê¸°] : http://bit.ly/43rPfOu"
    return result_text.strip()

# ì²­ì†Œ ë‹´ë‹¹ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
def get_cleaner_options():
    try:
        # ë°ì´í„°ë² ì´ìŠ¤ ì†ì„± ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        database = notion.databases.retrieve(database_id=DATABASE_ID)
        
        # 'ì²­ì†Œ ë‹´ë‹¹ì' ì†ì„± ì°¾ê¸°
        cleaner_property = database.get("properties", {}).get("ì²­ì†Œ ë‹´ë‹¹ì", {})
        
        # ì„ íƒ ì˜µì…˜ ê°€ì ¸ì˜¤ê¸°
        cleaner_options = []
        if cleaner_property.get("type") == "multi_select":
            options = cleaner_property.get("multi_select", {}).get("options", [])
            for option in options:
                cleaner_options.append({
                    "id": option.get("id"),
                    "name": option.get("name"),
                    "color": option.get("color")
                })
        
        return cleaner_options
    except Exception as e:
        print(f"âš ï¸ ì²­ì†Œ ë‹´ë‹¹ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜: {e}")
        return []

# ìº˜ë¦°ë”ìš© ë…¸ì…˜ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
def get_notion_calendar_data(year=None, month=None):
    if not year or not month:
        now = datetime.now()
        year = now.year
        month = now.month
    
    # í•´ë‹¹ ì›”ì˜ ì‹œì‘ì¼ê³¼ ë§ˆì§€ë§‰ ë‚ ì§œ ê³„ì‚°
    first_day = datetime(year, month, 1)
    last_day = datetime(year, month, calendar.monthrange(year, month)[1])
    
    # ë…¸ì…˜ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬
    response = notion.databases.query(
        database_id=DATABASE_ID,
        filter={
            "and": [
                {
                    "property": "ì²­ì†Œ ì¼ì •",
                    "date": {
                        "on_or_after": first_day.date().isoformat()
                    }
                },
                {
                    "property": "ì²­ì†Œ ì¼ì •",
                    "date": {
                        "on_or_before": last_day.date().isoformat()
                    }
                }
            ]
        }
    )
    
    # ê²°ê³¼ í¬ë§·íŒ…
    calendar_data = {}
    for page in response["results"]:
        props = page["properties"]
        date_data = props.get("ì²­ì†Œ ì¼ì •", {}).get("date")
        if not date_data or not date_data.get("start"):
            continue
            
        try:
            date = datetime.fromisoformat(date_data["start"])
            date_key = date.strftime('%Y-%m-%d')
            
            cleaner_items = props.get("ì²­ì†Œ ë‹´ë‹¹ì", {}).get("multi_select", [])
            cleaner_names = [item.get("name", "") for item in cleaner_items if item.get("name")]
            cleaner_name = ", ".join(cleaner_names) if cleaner_names else "ë¯¸ì§€ì •"
            
            status = props.get("ìƒíƒœ", {}).get("status", {}).get("name", "")
            people = props.get("ì˜ˆì•½ì¸ì›", {}).get("number", 0)
            
            calendar_data[date_key] = {
                "day": date.day,
                "cleaner": cleaner_name,
                "status": status,
                "people": people,
                "page_id": page["id"]
            }
        except Exception as e:
            print(f"âš ï¸ ìº˜ë¦°ë” ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜: {e}")
    
    return {
        "year": year,
        "month": month,
        "data": calendar_data
    }

# ë¯¸ë°°ì • ì²­ì†Œ ì¼ì • ê°€ì ¸ì˜¤ê¸°
def get_unassigned_cleaning_tasks():
    response = notion.databases.query(
        database_id=DATABASE_ID,
        filter={
            "property": "ìƒíƒœ",
            "status": {
                "equals": "ì²­ì†Œ ë°°ì • í•„ìš”"
            }
        },
        sorts=[
            {
                "property": "ì²­ì†Œ ì¼ì •",
                "direction": "ascending"
            }
        ]
    )
    
    tasks = []
    for page in response["results"]:
        props = page["properties"]
        date_data = props.get("ì²­ì†Œ ì¼ì •", {}).get("date")
        if not date_data or not date_data.get("start"):
            continue
            
        try:
            date_str = date_data["start"]
            date = datetime.fromisoformat(date_str)
            people = props.get("ì˜ˆì•½ì¸ì›", {}).get("number", 0)
            
            tasks.append({
                "date": date_str,
                "formatted_date": get_korean_date(date),
                "people": people,
                "page_id": page["id"]
            })
        except Exception as e:
            print(f"âš ï¸ ë¯¸ë°°ì • ì¼ì • íŒŒì‹± ì˜¤ë¥˜: {e}")
    
    return tasks

# ì£¼ê°„ ì¼ì • ê°€ì ¸ì˜¤ê¸°
def get_weekly_schedule():
    today = datetime.today()
    start_of_week = today - timedelta(days=today.weekday())  # ì´ë²ˆ ì£¼ ì›”ìš”ì¼
    end_of_week = start_of_week + timedelta(days=6)  # ì´ë²ˆ ì£¼ ì¼ìš”ì¼
    end_of_next_week = end_of_week + timedelta(days=7)  # ë‹¤ìŒ ì£¼ ì¼ìš”ì¼
    
    # ì´ë²ˆ ì£¼ ì¼ì •
    this_week = get_week_schedule(start_of_week, end_of_week)
    
    # ë‹¤ìŒ ì£¼ ì¼ì •
    next_week = get_week_schedule(end_of_week + timedelta(days=1), end_of_next_week)
    
    return {
        "this_week": this_week,
        "next_week": next_week
    }

# íŠ¹ì • ê¸°ê°„ì˜ ì¼ì • ê°€ì ¸ì˜¤ê¸° (ì£¼ê°„ ì¼ì • í—¬í¼ í•¨ìˆ˜)
def get_week_schedule(start_date, end_date):
    response = notion.databases.query(
        database_id=DATABASE_ID,
        filter={
            "and": [
                {
                    "property": "ì²­ì†Œ ì¼ì •",
                    "date": {
                        "on_or_after": start_date.date().isoformat()
                    }
                },
                {
                    "property": "ì²­ì†Œ ì¼ì •",
                    "date": {
                        "on_or_before": end_date.date().isoformat()
                    }
                }
            ]
        },
        sorts=[
            {
                "property": "ì²­ì†Œ ì¼ì •",
                "direction": "ascending"
            }
        ]
    )
    
    schedule = []
    for page in response["results"]:
        props = page["properties"]
        date_data = props.get("ì²­ì†Œ ì¼ì •", {}).get("date")
        if not date_data or not date_data.get("start"):
            continue
            
        try:
            date = datetime.fromisoformat(date_data["start"])
            people = props.get("ì˜ˆì•½ì¸ì›", {}).get("number", 0)
            
            cleaner_items = props.get("ì²­ì†Œ ë‹´ë‹¹ì", {}).get("multi_select", [])
            cleaner_names = [item.get("name", "") for item in cleaner_items if item.get("name")]
            cleaner_name = ", ".join(cleaner_names) if cleaner_names else "ë¯¸ì§€ì •"
            
            status = props.get("ìƒíƒœ", {}).get("status", {}).get("name", "")
            
            schedule.append({
                "date": date_data["start"],
                "formatted_date": get_korean_date(date),
                "people": people,
                "cleaner": cleaner_name,
                "status": status,
                "page_id": page["id"],
                "completed": status == "ì™„ë£Œ"
            })
        except Exception as e:
            print(f"âš ï¸ ì£¼ê°„ ì¼ì • íŒŒì‹± ì˜¤ë¥˜: {e}")
    
    return schedule

# ëª¨ë“  ì²­ì†Œ ì¼ì • ê°€ì ¸ì˜¤ê¸°
def get_all_cleaning_schedule(sort_by_date=True):
    response = notion.databases.query(
        database_id=DATABASE_ID,
        sorts=[
            {
                "property": "ì²­ì†Œ ì¼ì •",
                "direction": "ascending" if sort_by_date else "descending"
            }
        ]
    )
    
    schedule = []
    for page in response["results"]:
        props = page["properties"]
        date_data = props.get("ì²­ì†Œ ì¼ì •", {}).get("date")
        if not date_data or not date_data.get("start"):
            continue
            
        try:
            date = datetime.fromisoformat(date_data["start"])
            people = props.get("ì˜ˆì•½ì¸ì›", {}).get("number", 0)
            
            cleaner_items = props.get("ì²­ì†Œ ë‹´ë‹¹ì", {}).get("multi_select", [])
            cleaner_names = [item.get("name", "") for item in cleaner_items if item.get("name")]
            cleaner_name = ", ".join(cleaner_names) if cleaner_names else "ë¯¸ì§€ì •"
            
            status = props.get("ìƒíƒœ", {}).get("status", {}).get("name", "")
            
            schedule.append({
                "date": date_data["start"],
                "formatted_date": get_korean_date(date),
                "people": people,
                "cleaner": cleaner_name,
                "status": status,
                "page_id": page["id"],
                "completed": status == "ì™„ë£Œ"
            })
        except Exception as e:
            print(f"âš ï¸ ì²­ì†Œ ì¼ì • íŒŒì‹± ì˜¤ë¥˜: {e}")
    
    return schedule
